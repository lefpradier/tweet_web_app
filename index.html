<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tweet sentiment analysis</title>
  <link rel="stylesheet" href="assets/style.css">

</head>

<body> 
<h1 id="-tweet-web-app-https-github-com-lefpradier-tweet_web_app-" class="h1 article-title"><a href="https://github.com/lefpradier/tweet_web_app">Tweet sentiment analysis</a></h1>
<p><span class="tab">&emsp;Ce repository contient le code source d'une application de prédiction de sentiment. Il a été réalisé dans le cadre du projet 7 de la formation <em>Ingénieur IA</em> de l'organisme OpenClassrooms.</span>  </p>
<h2 id="motivation" class="h2 article-title">Motivation</h2>
<p><span class="tab">&emsp;Une entreprise souhaite pouvoir anticiper les bad buzz envers la marque. Le modèle développé est donc un moteur d’inférence de sentiment qui permet de détecter les mentions négatives sur les réseaux sociaux.</span></p>
<h2 id="jeu-de-donn-es" class="h2 article-title">Jeu de données</h2>
<p><span class="tab">&emsp;Pour mener à bien le projet, le jeu de données <a href="https://www.kaggle.com/datasets/kazanova/sentiment140">Sentiment140</a> a été utilisé. Ce dataset répertorie 1.6 million de tweets, annotés avec leur sentiment majoritaire : soit positif, soit négatif. Cette variable de sentiment est la target qu’on cherche à prédire. Au vu de l'objectif de modélisation, cette target a été réencodée en 1 pour les tweets négatifs et 0 pour les positifs.</span>
<span class="tab">&emsp;Les tweets ont été prétraités pour application d'analyse NLP :</span>  </p>
<ul class="goodlist">
<li>Suppression des URLs et des caractères répétés (<i>RegEx</i>)</li>
<li>Transformations lexicales avec <i>spaCy</i>
    <ul>
        <li>élimination des tweets non anglophones (modèle <i>fastlang</i>)</li> 
        <li>tokenization (découpage d’une phrase en vecteur de mots)</li>
        <li>suppression des stopwords</li>
        <li>lemmatization </li>
    </ul>
</li>
<li>Conversion des tweets en <i>bag of words</i></li>
</ul>
<h2 id="type-de-mod-le-et-performances" class="h2 article-title">Type de modèle et performances</h2>
<p><span class="tab">&emsp;Le modèle déployé est un réseau de neurones à couche LSTM (<i>Long Short Term Memory</i>). Les vecteurs de texte en entrée sont projetés par une couche de <i>word embedding</i>, ici une couche pré-entraînée <i>fasttext-commoncrawl</i> (300 dimensions). Les valeurs de sortie de l'embedder sont ensuite envoyés vers une couche récurrente de type LSTM bidirectionnelle, puis vers des couches denses qui calculent in fine la probabilité que le tweet exprime un sentiment négatif. Des couches de dropout avec la couche LSTM et entre les couches denses ont également été ajoutées pour faciliter l'entraînement du modèle.</span><br><span class="tab">&emsp;Afin d'optimiser les performances du modèle, le logiciel <i>Optuna</i> a été utilisé. Cette hyperparamétrisation a consisté à sélectionner la meilleure combinaison d’embedder et de valeurs de dropout, grâce à l'algorithme d'échantillonnage <i>TPE sampler</i>. Après fine tuning, le modèle obtient une <b>accuracy de 0.803</b> et une <b>PR AUC de 0.887</b> (en comparaison, on obtient respectivement 0.518 et 0.532 pour une régression logistique).</p>
<h2 id="d-ploiement" class="h2 article-title">Déploiement</h2>
<p><span class="tab">&emsp;Le modèle a été exposé sur API FastAPI, permettant de prédire le sentiment majoritaire d'un tweet, initialement <a href="https://sentiment-analysis-lefp.azurewebsites.net">déployée ici</a>. Une application Streamlit faisant appel à cette API a été initialement <a href="https://tweet-sentiment-lefp.streamlit.app/">déployée ici</a>.</span><br><span class="tab">&emsp;Lorsqu'un utilisateur entre un tweet dans l'application, cette dernière envoie une requête POST à l'API. L'API préprocesse le tweet reçu et, en l'absence d'erreur (texte vide, non anglophone, ou contenant trop de mots inconnus), prédit le sentiment associé. Ce score est ensuite retourné au frontend qui convertit cette réponse en image.</span><br><img src="assets/tweet-app.png" width=70% height=auto>
<span class="tab">&emsp;Un déploiement continue de l'application a été effectué via l'implémentation d'un workflow <i>GitHub Actions</i>. Lors d’un push, ce dernier compile l’API dans une image Docker, et envoie cette image vers une Azure Web App. Le frontend, lui, est déployé automatiquement depuis <i>GitHub</i> vers <i>Streamlit Cloud</i>.</span></p>
<h2 id="id-es-d-am-lioration" class="h2 article-title">Idées d'amélioration</h2>
<p><span class="tab">&emsp;Une piste d’amélioration pourrait consister à élargir le vocabulaire de l’embedding afin d’augmenter le nombre de mots pris en compte dans chaque tweet. Une autre mesure pourrait être d’augmenter la taille et le nombre des couches denses afin d’améliorer la séparation entre tweets positifs et négatifs.</span></p>

</body>
